//取反在日常生活中不要太简单，但是进了C就让我一头雾水，不是说不会，是太tm会了，但是没一个是完美的。
//首先是最无脑的取反办法，使用getchar，然后倒着printf。这种方法的优点是简单，缺点是数字位数确定，如果要更加通用，需要加上数字位数判定和if分支，及其麻烦。
//于是我想到第二种，直接写一个取反函数即可。

//取反函数也有很多，例如：
//一、普通法：
int length(int n)
{
	int sum = 0;
	while (n)
	{
		n /= 10;
		sum=sum+1;
	}
	return sum;
}
//这是最简单的计算位数的方法，原理就是不断消去最低位，直到变为0（消完），记录次数就算位数，但前几位若为0则无法计算进去。

//二、递归法
int length(int n)
{
    if(n==0)
        return 0;
    else
        return length(n/10)+1;
}
//核心原理和上面一样，缺点相同。

//三、公式法
#include <math.h>
int length(double n)
{
    return (int)log10(n)+1;
}
//原理不同，但缺点相同。

//其实上述办法可以统称数学法，数学中最高位的0是无意义的，经常舍去，所以是没有办法通过数学办法将其算到位数内的。
//其实按照这个思路，我们将其不看作数字，而是字符串就能解决了。
//strlen()函数可以解决，但是懒得学，而且锐格估计识别不出来。（鬼知道他那个编译器是什么东西）
//当然别的解决办法也有，不过想想还是算了。

//取反函数也很简单，从数学上有：
long reverse(long N)
{
	long tmp = 0;
	while (N != 0)
	{
		tmp = (tmp * 10 + N % 10);
		N = N / 10;
	}
	if (N < 0)
		return(-tmp);
	else
		return(tmp);
}
//很简单，但是你注意到我说【从数学上】，没错，这个函数也会忽略高位的【0】

//没办法，最后只能选择switch+if的方式了。

